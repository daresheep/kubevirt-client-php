<?php
/**
 * V1MigrationConfiguration
 *
 * PHP version 5
 *
 * @category Class
 * @package  Swagger\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * KubeVirt API
 *
 * This is KubeVirt API an add-on for Kubernetes.
 *
 * OpenAPI spec version: 1.0.0
 * Contact: kubevirt-dev@googlegroups.com
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 2.4.19
 */

/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace Swagger\Client\Model;

use \ArrayAccess;
use \Swagger\Client\ObjectSerializer;

/**
 * V1MigrationConfiguration Class Doc Comment
 *
 * @category Class
 * @description MigrationConfiguration holds migration options
 * @package  Swagger\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class V1MigrationConfiguration implements ModelInterface, ArrayAccess
{
    const DISCRIMINATOR = null;

    /**
      * The original name of the model.
      *
      * @var string
      */
    protected static $swaggerModelName = 'v1.MigrationConfiguration';

    /**
      * Array of property to type mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $swaggerTypes = [
        'allow_auto_converge' => 'bool',
        'allow_post_copy' => 'bool',
        'bandwidth_per_migration' => '\Swagger\Client\Model\K8sIoApimachineryPkgApiResourceQuantity',
        'completion_timeout_per_gi_b' => 'int',
        'node_drain_taint_key' => 'string',
        'parallel_migrations_per_cluster' => 'int',
        'parallel_outbound_migrations_per_node' => 'int',
        'progress_timeout' => 'int',
        'unsafe_migration_override' => 'bool'
    ];

    /**
      * Array of property to format mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $swaggerFormats = [
        'allow_auto_converge' => null,
        'allow_post_copy' => null,
        'bandwidth_per_migration' => null,
        'completion_timeout_per_gi_b' => 'int64',
        'node_drain_taint_key' => null,
        'parallel_migrations_per_cluster' => 'int64',
        'parallel_outbound_migrations_per_node' => 'int64',
        'progress_timeout' => 'int64',
        'unsafe_migration_override' => null
    ];

    /**
     * Array of property to type mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function swaggerTypes()
    {
        return self::$swaggerTypes;
    }

    /**
     * Array of property to format mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function swaggerFormats()
    {
        return self::$swaggerFormats;
    }

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @var string[]
     */
    protected static $attributeMap = [
        'allow_auto_converge' => 'allowAutoConverge',
        'allow_post_copy' => 'allowPostCopy',
        'bandwidth_per_migration' => 'bandwidthPerMigration',
        'completion_timeout_per_gi_b' => 'completionTimeoutPerGiB',
        'node_drain_taint_key' => 'nodeDrainTaintKey',
        'parallel_migrations_per_cluster' => 'parallelMigrationsPerCluster',
        'parallel_outbound_migrations_per_node' => 'parallelOutboundMigrationsPerNode',
        'progress_timeout' => 'progressTimeout',
        'unsafe_migration_override' => 'unsafeMigrationOverride'
    ];

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @var string[]
     */
    protected static $setters = [
        'allow_auto_converge' => 'setAllowAutoConverge',
        'allow_post_copy' => 'setAllowPostCopy',
        'bandwidth_per_migration' => 'setBandwidthPerMigration',
        'completion_timeout_per_gi_b' => 'setCompletionTimeoutPerGiB',
        'node_drain_taint_key' => 'setNodeDrainTaintKey',
        'parallel_migrations_per_cluster' => 'setParallelMigrationsPerCluster',
        'parallel_outbound_migrations_per_node' => 'setParallelOutboundMigrationsPerNode',
        'progress_timeout' => 'setProgressTimeout',
        'unsafe_migration_override' => 'setUnsafeMigrationOverride'
    ];

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @var string[]
     */
    protected static $getters = [
        'allow_auto_converge' => 'getAllowAutoConverge',
        'allow_post_copy' => 'getAllowPostCopy',
        'bandwidth_per_migration' => 'getBandwidthPerMigration',
        'completion_timeout_per_gi_b' => 'getCompletionTimeoutPerGiB',
        'node_drain_taint_key' => 'getNodeDrainTaintKey',
        'parallel_migrations_per_cluster' => 'getParallelMigrationsPerCluster',
        'parallel_outbound_migrations_per_node' => 'getParallelOutboundMigrationsPerNode',
        'progress_timeout' => 'getProgressTimeout',
        'unsafe_migration_override' => 'getUnsafeMigrationOverride'
    ];

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @return array
     */
    public static function attributeMap()
    {
        return self::$attributeMap;
    }

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @return array
     */
    public static function setters()
    {
        return self::$setters;
    }

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @return array
     */
    public static function getters()
    {
        return self::$getters;
    }

    /**
     * The original name of the model.
     *
     * @return string
     */
    public function getModelName()
    {
        return self::$swaggerModelName;
    }

    

    

    /**
     * Associative array for storing property values
     *
     * @var mixed[]
     */
    protected $container = [];

    /**
     * Constructor
     *
     * @param mixed[] $data Associated array of property values
     *                      initializing the model
     */
    public function __construct(array $data = null)
    {
        $this->container['allow_auto_converge'] = isset($data['allow_auto_converge']) ? $data['allow_auto_converge'] : null;
        $this->container['allow_post_copy'] = isset($data['allow_post_copy']) ? $data['allow_post_copy'] : null;
        $this->container['bandwidth_per_migration'] = isset($data['bandwidth_per_migration']) ? $data['bandwidth_per_migration'] : null;
        $this->container['completion_timeout_per_gi_b'] = isset($data['completion_timeout_per_gi_b']) ? $data['completion_timeout_per_gi_b'] : null;
        $this->container['node_drain_taint_key'] = isset($data['node_drain_taint_key']) ? $data['node_drain_taint_key'] : null;
        $this->container['parallel_migrations_per_cluster'] = isset($data['parallel_migrations_per_cluster']) ? $data['parallel_migrations_per_cluster'] : null;
        $this->container['parallel_outbound_migrations_per_node'] = isset($data['parallel_outbound_migrations_per_node']) ? $data['parallel_outbound_migrations_per_node'] : null;
        $this->container['progress_timeout'] = isset($data['progress_timeout']) ? $data['progress_timeout'] : null;
        $this->container['unsafe_migration_override'] = isset($data['unsafe_migration_override']) ? $data['unsafe_migration_override'] : null;
    }

    /**
     * Show all the invalid properties with reasons.
     *
     * @return array invalid properties with reasons
     */
    public function listInvalidProperties()
    {
        $invalidProperties = [];

        return $invalidProperties;
    }

    /**
     * Validate all the properties in the model
     * return true if all passed
     *
     * @return bool True if all properties are valid
     */
    public function valid()
    {
        return count($this->listInvalidProperties()) === 0;
    }


    /**
     * Gets allow_auto_converge
     *
     * @return bool
     */
    public function getAllowAutoConverge()
    {
        return $this->container['allow_auto_converge'];
    }

    /**
     * Sets allow_auto_converge
     *
     * @param bool $allow_auto_converge allow_auto_converge
     *
     * @return $this
     */
    public function setAllowAutoConverge($allow_auto_converge)
    {
        $this->container['allow_auto_converge'] = $allow_auto_converge;

        return $this;
    }

    /**
     * Gets allow_post_copy
     *
     * @return bool
     */
    public function getAllowPostCopy()
    {
        return $this->container['allow_post_copy'];
    }

    /**
     * Sets allow_post_copy
     *
     * @param bool $allow_post_copy allow_post_copy
     *
     * @return $this
     */
    public function setAllowPostCopy($allow_post_copy)
    {
        $this->container['allow_post_copy'] = $allow_post_copy;

        return $this;
    }

    /**
     * Gets bandwidth_per_migration
     *
     * @return \Swagger\Client\Model\K8sIoApimachineryPkgApiResourceQuantity
     */
    public function getBandwidthPerMigration()
    {
        return $this->container['bandwidth_per_migration'];
    }

    /**
     * Sets bandwidth_per_migration
     *
     * @param \Swagger\Client\Model\K8sIoApimachineryPkgApiResourceQuantity $bandwidth_per_migration bandwidth_per_migration
     *
     * @return $this
     */
    public function setBandwidthPerMigration($bandwidth_per_migration)
    {
        $this->container['bandwidth_per_migration'] = $bandwidth_per_migration;

        return $this;
    }

    /**
     * Gets completion_timeout_per_gi_b
     *
     * @return int
     */
    public function getCompletionTimeoutPerGiB()
    {
        return $this->container['completion_timeout_per_gi_b'];
    }

    /**
     * Sets completion_timeout_per_gi_b
     *
     * @param int $completion_timeout_per_gi_b completion_timeout_per_gi_b
     *
     * @return $this
     */
    public function setCompletionTimeoutPerGiB($completion_timeout_per_gi_b)
    {
        $this->container['completion_timeout_per_gi_b'] = $completion_timeout_per_gi_b;

        return $this;
    }

    /**
     * Gets node_drain_taint_key
     *
     * @return string
     */
    public function getNodeDrainTaintKey()
    {
        return $this->container['node_drain_taint_key'];
    }

    /**
     * Sets node_drain_taint_key
     *
     * @param string $node_drain_taint_key node_drain_taint_key
     *
     * @return $this
     */
    public function setNodeDrainTaintKey($node_drain_taint_key)
    {
        $this->container['node_drain_taint_key'] = $node_drain_taint_key;

        return $this;
    }

    /**
     * Gets parallel_migrations_per_cluster
     *
     * @return int
     */
    public function getParallelMigrationsPerCluster()
    {
        return $this->container['parallel_migrations_per_cluster'];
    }

    /**
     * Sets parallel_migrations_per_cluster
     *
     * @param int $parallel_migrations_per_cluster parallel_migrations_per_cluster
     *
     * @return $this
     */
    public function setParallelMigrationsPerCluster($parallel_migrations_per_cluster)
    {
        $this->container['parallel_migrations_per_cluster'] = $parallel_migrations_per_cluster;

        return $this;
    }

    /**
     * Gets parallel_outbound_migrations_per_node
     *
     * @return int
     */
    public function getParallelOutboundMigrationsPerNode()
    {
        return $this->container['parallel_outbound_migrations_per_node'];
    }

    /**
     * Sets parallel_outbound_migrations_per_node
     *
     * @param int $parallel_outbound_migrations_per_node parallel_outbound_migrations_per_node
     *
     * @return $this
     */
    public function setParallelOutboundMigrationsPerNode($parallel_outbound_migrations_per_node)
    {
        $this->container['parallel_outbound_migrations_per_node'] = $parallel_outbound_migrations_per_node;

        return $this;
    }

    /**
     * Gets progress_timeout
     *
     * @return int
     */
    public function getProgressTimeout()
    {
        return $this->container['progress_timeout'];
    }

    /**
     * Sets progress_timeout
     *
     * @param int $progress_timeout progress_timeout
     *
     * @return $this
     */
    public function setProgressTimeout($progress_timeout)
    {
        $this->container['progress_timeout'] = $progress_timeout;

        return $this;
    }

    /**
     * Gets unsafe_migration_override
     *
     * @return bool
     */
    public function getUnsafeMigrationOverride()
    {
        return $this->container['unsafe_migration_override'];
    }

    /**
     * Sets unsafe_migration_override
     *
     * @param bool $unsafe_migration_override unsafe_migration_override
     *
     * @return $this
     */
    public function setUnsafeMigrationOverride($unsafe_migration_override)
    {
        $this->container['unsafe_migration_override'] = $unsafe_migration_override;

        return $this;
    }
    /**
     * Returns true if offset exists. False otherwise.
     *
     * @param integer $offset Offset
     *
     * @return boolean
     */
    public function offsetExists($offset)
    {
        return isset($this->container[$offset]);
    }

    /**
     * Gets offset.
     *
     * @param integer $offset Offset
     *
     * @return mixed
     */
    public function offsetGet($offset)
    {
        return isset($this->container[$offset]) ? $this->container[$offset] : null;
    }

    /**
     * Sets value based on offset.
     *
     * @param integer $offset Offset
     * @param mixed   $value  Value to be set
     *
     * @return void
     */
    public function offsetSet($offset, $value)
    {
        if (is_null($offset)) {
            $this->container[] = $value;
        } else {
            $this->container[$offset] = $value;
        }
    }

    /**
     * Unsets offset.
     *
     * @param integer $offset Offset
     *
     * @return void
     */
    public function offsetUnset($offset)
    {
        unset($this->container[$offset]);
    }

    /**
     * Gets the string presentation of the object
     *
     * @return string
     */
    public function __toString()
    {
        if (defined('JSON_PRETTY_PRINT')) { // use JSON pretty print
            return json_encode(
                ObjectSerializer::sanitizeForSerialization($this),
                JSON_PRETTY_PRINT
            );
        }

        return json_encode(ObjectSerializer::sanitizeForSerialization($this));
    }
}


