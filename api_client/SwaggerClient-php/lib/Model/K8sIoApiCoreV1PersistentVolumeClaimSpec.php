<?php
/**
 * K8sIoApiCoreV1PersistentVolumeClaimSpec
 *
 * PHP version 5
 *
 * @category Class
 * @package  Swagger\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * KubeVirt API
 *
 * This is KubeVirt API an add-on for Kubernetes.
 *
 * OpenAPI spec version: 1.0.0
 * Contact: kubevirt-dev@googlegroups.com
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 2.4.19
 */

/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace Swagger\Client\Model;

use \ArrayAccess;
use \Swagger\Client\ObjectSerializer;

/**
 * K8sIoApiCoreV1PersistentVolumeClaimSpec Class Doc Comment
 *
 * @category Class
 * @description PersistentVolumeClaimSpec describes the common attributes of storage devices and allows a Source for provider-specific attributes
 * @package  Swagger\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class K8sIoApiCoreV1PersistentVolumeClaimSpec implements ModelInterface, ArrayAccess
{
    const DISCRIMINATOR = null;

    /**
      * The original name of the model.
      *
      * @var string
      */
    protected static $swaggerModelName = 'k8s.io.api.core.v1.PersistentVolumeClaimSpec';

    /**
      * Array of property to type mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $swaggerTypes = [
        'access_modes' => 'string[]',
        'data_source' => '\Swagger\Client\Model\K8sIoApiCoreV1TypedLocalObjectReference',
        'resources' => '\Swagger\Client\Model\K8sIoApiCoreV1ResourceRequirements',
        'selector' => '\Swagger\Client\Model\K8sIoApimachineryPkgApisMetaV1LabelSelector',
        'storage_class_name' => 'string',
        'volume_mode' => 'string',
        'volume_name' => 'string'
    ];

    /**
      * Array of property to format mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $swaggerFormats = [
        'access_modes' => null,
        'data_source' => null,
        'resources' => null,
        'selector' => null,
        'storage_class_name' => null,
        'volume_mode' => null,
        'volume_name' => null
    ];

    /**
     * Array of property to type mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function swaggerTypes()
    {
        return self::$swaggerTypes;
    }

    /**
     * Array of property to format mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function swaggerFormats()
    {
        return self::$swaggerFormats;
    }

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @var string[]
     */
    protected static $attributeMap = [
        'access_modes' => 'accessModes',
        'data_source' => 'dataSource',
        'resources' => 'resources',
        'selector' => 'selector',
        'storage_class_name' => 'storageClassName',
        'volume_mode' => 'volumeMode',
        'volume_name' => 'volumeName'
    ];

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @var string[]
     */
    protected static $setters = [
        'access_modes' => 'setAccessModes',
        'data_source' => 'setDataSource',
        'resources' => 'setResources',
        'selector' => 'setSelector',
        'storage_class_name' => 'setStorageClassName',
        'volume_mode' => 'setVolumeMode',
        'volume_name' => 'setVolumeName'
    ];

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @var string[]
     */
    protected static $getters = [
        'access_modes' => 'getAccessModes',
        'data_source' => 'getDataSource',
        'resources' => 'getResources',
        'selector' => 'getSelector',
        'storage_class_name' => 'getStorageClassName',
        'volume_mode' => 'getVolumeMode',
        'volume_name' => 'getVolumeName'
    ];

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @return array
     */
    public static function attributeMap()
    {
        return self::$attributeMap;
    }

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @return array
     */
    public static function setters()
    {
        return self::$setters;
    }

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @return array
     */
    public static function getters()
    {
        return self::$getters;
    }

    /**
     * The original name of the model.
     *
     * @return string
     */
    public function getModelName()
    {
        return self::$swaggerModelName;
    }

    

    

    /**
     * Associative array for storing property values
     *
     * @var mixed[]
     */
    protected $container = [];

    /**
     * Constructor
     *
     * @param mixed[] $data Associated array of property values
     *                      initializing the model
     */
    public function __construct(array $data = null)
    {
        $this->container['access_modes'] = isset($data['access_modes']) ? $data['access_modes'] : null;
        $this->container['data_source'] = isset($data['data_source']) ? $data['data_source'] : null;
        $this->container['resources'] = isset($data['resources']) ? $data['resources'] : null;
        $this->container['selector'] = isset($data['selector']) ? $data['selector'] : null;
        $this->container['storage_class_name'] = isset($data['storage_class_name']) ? $data['storage_class_name'] : null;
        $this->container['volume_mode'] = isset($data['volume_mode']) ? $data['volume_mode'] : null;
        $this->container['volume_name'] = isset($data['volume_name']) ? $data['volume_name'] : null;
    }

    /**
     * Show all the invalid properties with reasons.
     *
     * @return array invalid properties with reasons
     */
    public function listInvalidProperties()
    {
        $invalidProperties = [];

        return $invalidProperties;
    }

    /**
     * Validate all the properties in the model
     * return true if all passed
     *
     * @return bool True if all properties are valid
     */
    public function valid()
    {
        return count($this->listInvalidProperties()) === 0;
    }


    /**
     * Gets access_modes
     *
     * @return string[]
     */
    public function getAccessModes()
    {
        return $this->container['access_modes'];
    }

    /**
     * Sets access_modes
     *
     * @param string[] $access_modes AccessModes contains the desired access modes the volume should have. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1
     *
     * @return $this
     */
    public function setAccessModes($access_modes)
    {
        $this->container['access_modes'] = $access_modes;

        return $this;
    }

    /**
     * Gets data_source
     *
     * @return \Swagger\Client\Model\K8sIoApiCoreV1TypedLocalObjectReference
     */
    public function getDataSource()
    {
        return $this->container['data_source'];
    }

    /**
     * Sets data_source
     *
     * @param \Swagger\Client\Model\K8sIoApiCoreV1TypedLocalObjectReference $data_source This field can be used to specify either: * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot) * An existing PVC (PersistentVolumeClaim) * An existing custom resource that implements data population (Alpha) In order to use custom resource types that implement data population, the AnyVolumeDataSource feature gate must be enabled. If the provisioner or an external controller can support the specified data source, it will create a new volume based on the contents of the specified data source.
     *
     * @return $this
     */
    public function setDataSource($data_source)
    {
        $this->container['data_source'] = $data_source;

        return $this;
    }

    /**
     * Gets resources
     *
     * @return \Swagger\Client\Model\K8sIoApiCoreV1ResourceRequirements
     */
    public function getResources()
    {
        return $this->container['resources'];
    }

    /**
     * Sets resources
     *
     * @param \Swagger\Client\Model\K8sIoApiCoreV1ResourceRequirements $resources Resources represents the minimum resources the volume should have. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
     *
     * @return $this
     */
    public function setResources($resources)
    {
        $this->container['resources'] = $resources;

        return $this;
    }

    /**
     * Gets selector
     *
     * @return \Swagger\Client\Model\K8sIoApimachineryPkgApisMetaV1LabelSelector
     */
    public function getSelector()
    {
        return $this->container['selector'];
    }

    /**
     * Sets selector
     *
     * @param \Swagger\Client\Model\K8sIoApimachineryPkgApisMetaV1LabelSelector $selector A label query over volumes to consider for binding.
     *
     * @return $this
     */
    public function setSelector($selector)
    {
        $this->container['selector'] = $selector;

        return $this;
    }

    /**
     * Gets storage_class_name
     *
     * @return string
     */
    public function getStorageClassName()
    {
        return $this->container['storage_class_name'];
    }

    /**
     * Sets storage_class_name
     *
     * @param string $storage_class_name Name of the StorageClass required by the claim. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1
     *
     * @return $this
     */
    public function setStorageClassName($storage_class_name)
    {
        $this->container['storage_class_name'] = $storage_class_name;

        return $this;
    }

    /**
     * Gets volume_mode
     *
     * @return string
     */
    public function getVolumeMode()
    {
        return $this->container['volume_mode'];
    }

    /**
     * Sets volume_mode
     *
     * @param string $volume_mode volumeMode defines what type of volume is required by the claim. Value of Filesystem is implied when not included in claim spec.
     *
     * @return $this
     */
    public function setVolumeMode($volume_mode)
    {
        $this->container['volume_mode'] = $volume_mode;

        return $this;
    }

    /**
     * Gets volume_name
     *
     * @return string
     */
    public function getVolumeName()
    {
        return $this->container['volume_name'];
    }

    /**
     * Sets volume_name
     *
     * @param string $volume_name VolumeName is the binding reference to the PersistentVolume backing this claim.
     *
     * @return $this
     */
    public function setVolumeName($volume_name)
    {
        $this->container['volume_name'] = $volume_name;

        return $this;
    }
    /**
     * Returns true if offset exists. False otherwise.
     *
     * @param integer $offset Offset
     *
     * @return boolean
     */
    public function offsetExists($offset)
    {
        return isset($this->container[$offset]);
    }

    /**
     * Gets offset.
     *
     * @param integer $offset Offset
     *
     * @return mixed
     */
    public function offsetGet($offset)
    {
        return isset($this->container[$offset]) ? $this->container[$offset] : null;
    }

    /**
     * Sets value based on offset.
     *
     * @param integer $offset Offset
     * @param mixed   $value  Value to be set
     *
     * @return void
     */
    public function offsetSet($offset, $value)
    {
        if (is_null($offset)) {
            $this->container[] = $value;
        } else {
            $this->container[$offset] = $value;
        }
    }

    /**
     * Unsets offset.
     *
     * @param integer $offset Offset
     *
     * @return void
     */
    public function offsetUnset($offset)
    {
        unset($this->container[$offset]);
    }

    /**
     * Gets the string presentation of the object
     *
     * @return string
     */
    public function __toString()
    {
        if (defined('JSON_PRETTY_PRINT')) { // use JSON pretty print
            return json_encode(
                ObjectSerializer::sanitizeForSerialization($this),
                JSON_PRETTY_PRINT
            );
        }

        return json_encode(ObjectSerializer::sanitizeForSerialization($this));
    }
}


