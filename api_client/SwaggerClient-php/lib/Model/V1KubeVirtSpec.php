<?php
/**
 * V1KubeVirtSpec
 *
 * PHP version 5
 *
 * @category Class
 * @package  Swagger\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * KubeVirt API
 *
 * This is KubeVirt API an add-on for Kubernetes.
 *
 * OpenAPI spec version: 1.0.0
 * Contact: kubevirt-dev@googlegroups.com
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 2.4.19
 */

/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace Swagger\Client\Model;

use \ArrayAccess;
use \Swagger\Client\ObjectSerializer;

/**
 * V1KubeVirtSpec Class Doc Comment
 *
 * @category Class
 * @package  Swagger\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class V1KubeVirtSpec implements ModelInterface, ArrayAccess
{
    const DISCRIMINATOR = null;

    /**
      * The original name of the model.
      *
      * @var string
      */
    protected static $swaggerModelName = 'v1.KubeVirtSpec';

    /**
      * Array of property to type mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $swaggerTypes = [
        'certificate_rotate_strategy' => '\Swagger\Client\Model\V1KubeVirtCertificateRotateStrategy',
        'configuration' => '\Swagger\Client\Model\V1KubeVirtConfiguration',
        'customize_components' => '\Swagger\Client\Model\V1CustomizeComponents',
        'image_pull_policy' => 'string',
        'image_registry' => 'string',
        'image_tag' => 'string',
        'infra' => '\Swagger\Client\Model\V1ComponentConfig',
        'monitor_account' => 'string',
        'monitor_namespace' => 'string',
        'product_name' => 'string',
        'product_version' => 'string',
        'uninstall_strategy' => 'string',
        'workload_update_strategy' => '\Swagger\Client\Model\V1KubeVirtWorkloadUpdateStrategy',
        'workloads' => '\Swagger\Client\Model\V1ComponentConfig'
    ];

    /**
      * Array of property to format mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $swaggerFormats = [
        'certificate_rotate_strategy' => null,
        'configuration' => null,
        'customize_components' => null,
        'image_pull_policy' => null,
        'image_registry' => null,
        'image_tag' => null,
        'infra' => null,
        'monitor_account' => null,
        'monitor_namespace' => null,
        'product_name' => null,
        'product_version' => null,
        'uninstall_strategy' => null,
        'workload_update_strategy' => null,
        'workloads' => null
    ];

    /**
     * Array of property to type mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function swaggerTypes()
    {
        return self::$swaggerTypes;
    }

    /**
     * Array of property to format mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function swaggerFormats()
    {
        return self::$swaggerFormats;
    }

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @var string[]
     */
    protected static $attributeMap = [
        'certificate_rotate_strategy' => 'certificateRotateStrategy',
        'configuration' => 'configuration',
        'customize_components' => 'customizeComponents',
        'image_pull_policy' => 'imagePullPolicy',
        'image_registry' => 'imageRegistry',
        'image_tag' => 'imageTag',
        'infra' => 'infra',
        'monitor_account' => 'monitorAccount',
        'monitor_namespace' => 'monitorNamespace',
        'product_name' => 'productName',
        'product_version' => 'productVersion',
        'uninstall_strategy' => 'uninstallStrategy',
        'workload_update_strategy' => 'workloadUpdateStrategy',
        'workloads' => 'workloads'
    ];

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @var string[]
     */
    protected static $setters = [
        'certificate_rotate_strategy' => 'setCertificateRotateStrategy',
        'configuration' => 'setConfiguration',
        'customize_components' => 'setCustomizeComponents',
        'image_pull_policy' => 'setImagePullPolicy',
        'image_registry' => 'setImageRegistry',
        'image_tag' => 'setImageTag',
        'infra' => 'setInfra',
        'monitor_account' => 'setMonitorAccount',
        'monitor_namespace' => 'setMonitorNamespace',
        'product_name' => 'setProductName',
        'product_version' => 'setProductVersion',
        'uninstall_strategy' => 'setUninstallStrategy',
        'workload_update_strategy' => 'setWorkloadUpdateStrategy',
        'workloads' => 'setWorkloads'
    ];

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @var string[]
     */
    protected static $getters = [
        'certificate_rotate_strategy' => 'getCertificateRotateStrategy',
        'configuration' => 'getConfiguration',
        'customize_components' => 'getCustomizeComponents',
        'image_pull_policy' => 'getImagePullPolicy',
        'image_registry' => 'getImageRegistry',
        'image_tag' => 'getImageTag',
        'infra' => 'getInfra',
        'monitor_account' => 'getMonitorAccount',
        'monitor_namespace' => 'getMonitorNamespace',
        'product_name' => 'getProductName',
        'product_version' => 'getProductVersion',
        'uninstall_strategy' => 'getUninstallStrategy',
        'workload_update_strategy' => 'getWorkloadUpdateStrategy',
        'workloads' => 'getWorkloads'
    ];

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @return array
     */
    public static function attributeMap()
    {
        return self::$attributeMap;
    }

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @return array
     */
    public static function setters()
    {
        return self::$setters;
    }

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @return array
     */
    public static function getters()
    {
        return self::$getters;
    }

    /**
     * The original name of the model.
     *
     * @return string
     */
    public function getModelName()
    {
        return self::$swaggerModelName;
    }

    

    

    /**
     * Associative array for storing property values
     *
     * @var mixed[]
     */
    protected $container = [];

    /**
     * Constructor
     *
     * @param mixed[] $data Associated array of property values
     *                      initializing the model
     */
    public function __construct(array $data = null)
    {
        $this->container['certificate_rotate_strategy'] = isset($data['certificate_rotate_strategy']) ? $data['certificate_rotate_strategy'] : null;
        $this->container['configuration'] = isset($data['configuration']) ? $data['configuration'] : null;
        $this->container['customize_components'] = isset($data['customize_components']) ? $data['customize_components'] : null;
        $this->container['image_pull_policy'] = isset($data['image_pull_policy']) ? $data['image_pull_policy'] : null;
        $this->container['image_registry'] = isset($data['image_registry']) ? $data['image_registry'] : null;
        $this->container['image_tag'] = isset($data['image_tag']) ? $data['image_tag'] : null;
        $this->container['infra'] = isset($data['infra']) ? $data['infra'] : null;
        $this->container['monitor_account'] = isset($data['monitor_account']) ? $data['monitor_account'] : null;
        $this->container['monitor_namespace'] = isset($data['monitor_namespace']) ? $data['monitor_namespace'] : null;
        $this->container['product_name'] = isset($data['product_name']) ? $data['product_name'] : null;
        $this->container['product_version'] = isset($data['product_version']) ? $data['product_version'] : null;
        $this->container['uninstall_strategy'] = isset($data['uninstall_strategy']) ? $data['uninstall_strategy'] : null;
        $this->container['workload_update_strategy'] = isset($data['workload_update_strategy']) ? $data['workload_update_strategy'] : null;
        $this->container['workloads'] = isset($data['workloads']) ? $data['workloads'] : null;
    }

    /**
     * Show all the invalid properties with reasons.
     *
     * @return array invalid properties with reasons
     */
    public function listInvalidProperties()
    {
        $invalidProperties = [];

        return $invalidProperties;
    }

    /**
     * Validate all the properties in the model
     * return true if all passed
     *
     * @return bool True if all properties are valid
     */
    public function valid()
    {
        return count($this->listInvalidProperties()) === 0;
    }


    /**
     * Gets certificate_rotate_strategy
     *
     * @return \Swagger\Client\Model\V1KubeVirtCertificateRotateStrategy
     */
    public function getCertificateRotateStrategy()
    {
        return $this->container['certificate_rotate_strategy'];
    }

    /**
     * Sets certificate_rotate_strategy
     *
     * @param \Swagger\Client\Model\V1KubeVirtCertificateRotateStrategy $certificate_rotate_strategy certificate_rotate_strategy
     *
     * @return $this
     */
    public function setCertificateRotateStrategy($certificate_rotate_strategy)
    {
        $this->container['certificate_rotate_strategy'] = $certificate_rotate_strategy;

        return $this;
    }

    /**
     * Gets configuration
     *
     * @return \Swagger\Client\Model\V1KubeVirtConfiguration
     */
    public function getConfiguration()
    {
        return $this->container['configuration'];
    }

    /**
     * Sets configuration
     *
     * @param \Swagger\Client\Model\V1KubeVirtConfiguration $configuration holds kubevirt configurations. same as the virt-configMap
     *
     * @return $this
     */
    public function setConfiguration($configuration)
    {
        $this->container['configuration'] = $configuration;

        return $this;
    }

    /**
     * Gets customize_components
     *
     * @return \Swagger\Client\Model\V1CustomizeComponents
     */
    public function getCustomizeComponents()
    {
        return $this->container['customize_components'];
    }

    /**
     * Sets customize_components
     *
     * @param \Swagger\Client\Model\V1CustomizeComponents $customize_components customize_components
     *
     * @return $this
     */
    public function setCustomizeComponents($customize_components)
    {
        $this->container['customize_components'] = $customize_components;

        return $this;
    }

    /**
     * Gets image_pull_policy
     *
     * @return string
     */
    public function getImagePullPolicy()
    {
        return $this->container['image_pull_policy'];
    }

    /**
     * Sets image_pull_policy
     *
     * @param string $image_pull_policy The ImagePullPolicy to use.
     *
     * @return $this
     */
    public function setImagePullPolicy($image_pull_policy)
    {
        $this->container['image_pull_policy'] = $image_pull_policy;

        return $this;
    }

    /**
     * Gets image_registry
     *
     * @return string
     */
    public function getImageRegistry()
    {
        return $this->container['image_registry'];
    }

    /**
     * Sets image_registry
     *
     * @param string $image_registry The image registry to pull the container images from Defaults to the same registry the operator's container image is pulled from.
     *
     * @return $this
     */
    public function setImageRegistry($image_registry)
    {
        $this->container['image_registry'] = $image_registry;

        return $this;
    }

    /**
     * Gets image_tag
     *
     * @return string
     */
    public function getImageTag()
    {
        return $this->container['image_tag'];
    }

    /**
     * Sets image_tag
     *
     * @param string $image_tag The image tag to use for the continer images installed. Defaults to the same tag as the operator's container image.
     *
     * @return $this
     */
    public function setImageTag($image_tag)
    {
        $this->container['image_tag'] = $image_tag;

        return $this;
    }

    /**
     * Gets infra
     *
     * @return \Swagger\Client\Model\V1ComponentConfig
     */
    public function getInfra()
    {
        return $this->container['infra'];
    }

    /**
     * Sets infra
     *
     * @param \Swagger\Client\Model\V1ComponentConfig $infra selectors and tolerations that should apply to KubeVirt infrastructure components
     *
     * @return $this
     */
    public function setInfra($infra)
    {
        $this->container['infra'] = $infra;

        return $this;
    }

    /**
     * Gets monitor_account
     *
     * @return string
     */
    public function getMonitorAccount()
    {
        return $this->container['monitor_account'];
    }

    /**
     * Sets monitor_account
     *
     * @param string $monitor_account The name of the Prometheus service account that needs read-access to KubeVirt endpoints Defaults to prometheus-k8s
     *
     * @return $this
     */
    public function setMonitorAccount($monitor_account)
    {
        $this->container['monitor_account'] = $monitor_account;

        return $this;
    }

    /**
     * Gets monitor_namespace
     *
     * @return string
     */
    public function getMonitorNamespace()
    {
        return $this->container['monitor_namespace'];
    }

    /**
     * Sets monitor_namespace
     *
     * @param string $monitor_namespace The namespace Prometheus is deployed in Defaults to openshift-monitor
     *
     * @return $this
     */
    public function setMonitorNamespace($monitor_namespace)
    {
        $this->container['monitor_namespace'] = $monitor_namespace;

        return $this;
    }

    /**
     * Gets product_name
     *
     * @return string
     */
    public function getProductName()
    {
        return $this->container['product_name'];
    }

    /**
     * Sets product_name
     *
     * @param string $product_name Designate the apps.kubevirt.io/part-of label for KubeVirt components. Useful if KubeVirt is included as part of a product. If ProductName is not specified, the part-of label will be omitted.
     *
     * @return $this
     */
    public function setProductName($product_name)
    {
        $this->container['product_name'] = $product_name;

        return $this;
    }

    /**
     * Gets product_version
     *
     * @return string
     */
    public function getProductVersion()
    {
        return $this->container['product_version'];
    }

    /**
     * Sets product_version
     *
     * @param string $product_version Designate the apps.kubevirt.io/version label for KubeVirt components. Useful if KubeVirt is included as part of a product. If ProductVersion is not specified, KubeVirt's version will be used.
     *
     * @return $this
     */
    public function setProductVersion($product_version)
    {
        $this->container['product_version'] = $product_version;

        return $this;
    }

    /**
     * Gets uninstall_strategy
     *
     * @return string
     */
    public function getUninstallStrategy()
    {
        return $this->container['uninstall_strategy'];
    }

    /**
     * Sets uninstall_strategy
     *
     * @param string $uninstall_strategy Specifies if kubevirt can be deleted if workloads are still present. This is mainly a precaution to avoid accidental data loss
     *
     * @return $this
     */
    public function setUninstallStrategy($uninstall_strategy)
    {
        $this->container['uninstall_strategy'] = $uninstall_strategy;

        return $this;
    }

    /**
     * Gets workload_update_strategy
     *
     * @return \Swagger\Client\Model\V1KubeVirtWorkloadUpdateStrategy
     */
    public function getWorkloadUpdateStrategy()
    {
        return $this->container['workload_update_strategy'];
    }

    /**
     * Sets workload_update_strategy
     *
     * @param \Swagger\Client\Model\V1KubeVirtWorkloadUpdateStrategy $workload_update_strategy WorkloadUpdateStrategy defines at the cluster level how to handle automated workload updates
     *
     * @return $this
     */
    public function setWorkloadUpdateStrategy($workload_update_strategy)
    {
        $this->container['workload_update_strategy'] = $workload_update_strategy;

        return $this;
    }

    /**
     * Gets workloads
     *
     * @return \Swagger\Client\Model\V1ComponentConfig
     */
    public function getWorkloads()
    {
        return $this->container['workloads'];
    }

    /**
     * Sets workloads
     *
     * @param \Swagger\Client\Model\V1ComponentConfig $workloads selectors and tolerations that should apply to KubeVirt workloads
     *
     * @return $this
     */
    public function setWorkloads($workloads)
    {
        $this->container['workloads'] = $workloads;

        return $this;
    }
    /**
     * Returns true if offset exists. False otherwise.
     *
     * @param integer $offset Offset
     *
     * @return boolean
     */
    public function offsetExists($offset)
    {
        return isset($this->container[$offset]);
    }

    /**
     * Gets offset.
     *
     * @param integer $offset Offset
     *
     * @return mixed
     */
    public function offsetGet($offset)
    {
        return isset($this->container[$offset]) ? $this->container[$offset] : null;
    }

    /**
     * Sets value based on offset.
     *
     * @param integer $offset Offset
     * @param mixed   $value  Value to be set
     *
     * @return void
     */
    public function offsetSet($offset, $value)
    {
        if (is_null($offset)) {
            $this->container[] = $value;
        } else {
            $this->container[$offset] = $value;
        }
    }

    /**
     * Unsets offset.
     *
     * @param integer $offset Offset
     *
     * @return void
     */
    public function offsetUnset($offset)
    {
        unset($this->container[$offset]);
    }

    /**
     * Gets the string presentation of the object
     *
     * @return string
     */
    public function __toString()
    {
        if (defined('JSON_PRETTY_PRINT')) { // use JSON pretty print
            return json_encode(
                ObjectSerializer::sanitizeForSerialization($this),
                JSON_PRETTY_PRINT
            );
        }

        return json_encode(ObjectSerializer::sanitizeForSerialization($this));
    }
}


